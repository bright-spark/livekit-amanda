#!/usr/bin/env python3
"""Agent Startup Optimizer

This module optimizes the startup sequence of the LiveKit Amanda agent
to ensure it becomes responsive as quickly as possible, loading local
tools first before connecting to external MCP servers.
"""

import os
import logging
import asyncio
import time
from typing import List, Dict, Any, Optional, Union, Tuple
from datetime import datetime

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger("agent_startup")

# Import LiveKit agent components
from livekit.agents import Agent, AgentSession, JobContext, RunContext, function_tool

# Import necessary modules for tools
from dotenv import load_dotenv
load_dotenv()  # Ensure environment variables are loaded

class AgentStartupOptimizer:
    """
    Optimizes the startup sequence of the LiveKit Amanda agent to ensure
    it becomes responsive as quickly as possible, loading local tools first
    and then MCP servers.
    """
    
    def __init__(self):
        """Initialize the optimizer with default values."""
        self.tool_sources = []
        self.local_tools_loaded = False
        self.mcp_tools_loaded = False
        self.agent = None
        self.ctx = None
        self.session = None
        
        # Track loading states
        self.basic_tools_loaded = False
        self.search_tools_loaded = False
        self.enhanced_search_loaded = False
        self.background_embedding_started = False
        
        # Track registered tools to prevent duplicates
        self.registered_tool_names = set()  # Set of tool names that have been registered
        
        # Tool collections
        self.web_search_tools = []
        self.time_date_tools = []
        self.utility_tools = []
        self.job_search_tools = []
        
        # Import flags - explicitly check for false values to ensure disabled services stay disabled
        def is_enabled(env_var, default=""):
            value = os.environ.get(env_var, default).lower()
            if value in ("false", "0", "no"):
                return False
            return value in ("true", "1", "yes")
        
        self.has_brave_search = is_enabled("BRAVE_SEARCH_ENABLE")
        self.has_bing_search = is_enabled("BING_SEARCH_ENABLE")
        self.has_duckduckgo = is_enabled("DUCKDUCKGO_SEARCH_ENABLE")
        self.has_google_search = is_enabled("GOOGLE_SEARCH_ENABLE")
        self.has_locanto = is_enabled("LOCANTO_ENABLE")
        self.has_indeed = is_enabled("INDEED_ENABLE")
        self.has_wikipedia = is_enabled("WIKIPEDIA_ENABLE")
        self.has_local_tools = is_enabled("LOCAL_TOOLS")
        self.has_mcp_client = is_enabled("MCP_CLIENT")
        self.has_openweather = is_enabled("OPENWEATHER_ENABLE")
        self.has_enhanced_search = is_enabled("ENHANCED_SEARCH_ENABLE_RAG")
        self.has_background_embedding = is_enabled("ENABLE_BACKGROUND_EMBEDDING")
        
        # Track which tools were successfully loaded
        self.loaded_tools = {
            "brave_search": False,
            "bing_search": False,
            "duckduckgo_search": False,
            "google_search": False,
            "locanto": False,
            "indeed": False,
            "wikipedia": False,
            "local_tools": False,
            "mcp_client": False,
            "openweather": False,
            "enhanced_search_rag": False,
            "background_embedding": False
        }
        
        logger.info(f"Agent startup optimizer initialized with feature flags:")
        logger.info(f"  Brave Search: {self.has_brave_search}")
        logger.info(f"  Bing Search: {self.has_bing_search}")
        logger.info(f"  DuckDuckGo: {self.has_duckduckgo}")
        logger.info(f"  Google Search: {self.has_google_search}")
        logger.info(f"  Locanto: {self.has_locanto}")
        logger.info(f"  Indeed: {self.has_indeed}")
        logger.info(f"  Wikipedia: {self.has_wikipedia}")
        logger.info(f"  Local Tools: {self.has_local_tools}")
        logger.info(f"  MCP Client: {self.has_mcp_client}")
        logger.info(f"  OpenWeather: {self.has_openweather}")
        logger.info(f"  Enhanced Search RAG: {self.has_enhanced_search}")
        logger.info(f"  Background Embedding: {self.has_background_embedding}")
        
    async def initialize_agent(self, agent: Agent, ctx: JobContext):
        """
        Initialize the agent with optimized startup sequence.
        
        Args:
            agent: The LiveKit agent to optimize
            ctx: The job context for the agent
        """
        self.agent = agent
        self.ctx = ctx
        
        logger.info("Starting optimized agent initialization sequence")
        
        # Step 1: Make the agent responsive with minimal instructions
        await self.make_agent_responsive()

        # Step 2: Load basic tools synchronously
        await self.load_basic_tools()

        # Step 3: Load search tools synchronously
        await self.load_search_tools()

        # Optionally, load job search tools synchronously as well
        await self.load_job_search_tools()

        # --- Ensure all tools are registered ---
        all_tools = []
        if hasattr(self, "time_date_tools"):
            all_tools.extend(self.time_date_tools)
        if hasattr(self, "web_search_tools"):
            all_tools.extend(self.web_search_tools)
        if hasattr(self, "job_search_tools"):
            all_tools.extend(self.job_search_tools)
        if hasattr(self, "utility_tools"):
            all_tools.extend(self.utility_tools)
        # Add other tool lists if present

        await self.agent.update_tools(all_tools)
        logger.info(f"Final tool list registered: {[getattr(t, '__name__', str(t)) for t in all_tools]}")

        return self.agent
    
    async def make_agent_responsive(self):
        """
        Make the agent responsive as quickly as possible with minimal instructions.
        """
        logger.info("Making agent responsive with minimal configuration")
        
        # The agent already has initial instructions from the entrypoint function
        # So we just need to connect to the room and start the session
        
        # Connect to the room to make the agent responsive
        await self.ctx.connect()
        
        # Start the agent session
        self.session = AgentSession()
        await self.session.start(agent=self.agent, room=self.ctx.room)
        
        logger.info("Agent is now responsive with minimal configuration")
        
    async def load_basic_tools(self):
        """
        Load basic tools that don't require external services.
        """
        logger.info("Loading basic tools")
        
        # Add basic time and date tools
        await self.register_time_date_tools()

        # Update instructions to reflect basic tools
        await self.update_agent_instructions("Basic tools loaded")

        # Mark basic tools as loaded
        self.basic_tools_loaded = True
        self.tool_sources.append("Basic Tools")

        
    async def register_time_date_tools(self):
        """
        Register time and date tools with the agent.
        """
        @function_tool
        async def get_current_time(context: RunContext, timezone: str = "UTC") -> str:
            """Get the current time in the specified timezone."""
            try:
                import pytz
                from datetime import datetime
                
                # Get the timezone
                tz = pytz.timezone(timezone)
                
                # Get the current time in the specified timezone
                now = datetime.now(tz)
                
                # Format the time
                formatted_time = now.strftime("%Y-%m-%d %H:%M:%S %Z%z")
                
                return f"The current time in {timezone} is {formatted_time}"
            except Exception as e:
                return f"Error getting time: {str(e)}"
        
        @function_tool
        async def get_current_date(context: RunContext, timezone: str = "UTC") -> str:
            """Get the current date in the specified timezone."""
            try:
                import pytz
                from datetime import datetime
                
                # Get the timezone
                tz = pytz.timezone(timezone)
                
                # Get the current date in the specified timezone
                current_date = datetime.now(tz)
                
                # Format the date
                formatted_date = current_date.strftime("%Y-%m-%d %A")
                
                return f"The current date in {timezone} is {formatted_date}"
            except Exception as e:
                return f"Error getting current date: {str(e)}"
        
        # Register the tools with the agent
        self.time_date_tools = [get_current_time, get_current_date]
        
        # Register tools with the agent using the proper update_tools method
        try:
            # Get current tools
            current_tools = self.agent.tools if hasattr(self.agent, 'tools') else []
            
            # Add our new tools
            all_tools = list(current_tools) + self.time_date_tools
            
            # Update the agent's tools
            await self.agent.update_tools(all_tools)
            
            tool_names = [tool.__name__ for tool in self.time_date_tools]
            logger.info(f"Added time and date tools to agent: {', '.join(tool_names)}")
            
            # Update agent instructions with specific tool names
            await self.update_agent_instructions(f"Basic tools loaded: {', '.join(tool_names)}")
        except Exception as e:
            logger.error(f"Error adding time and date tools: {e}")
            logger.warning("Could not add time and date tools to agent")
        
    async def load_search_tools(self):
        """
        Load search tools based on enabled providers.
        """
        logger.info("Loading search tools")
        
        # Load search tools based on enabled providers
        if self.has_brave_search:
            await self.register_brave_search()
        
        if self.has_bing_search:
            await self.register_bing_search()
        
        if self.has_duckduckgo:
            await self.register_duckduckgo_search()
            
        if self.has_google_search:
            await self.register_google_search()
            
        if self.has_wikipedia:
            await self.register_wikipedia_search()
        
        # Register the combined web_search tool
        await self.register_web_search()
        
        # Update instructions to reflect search tools
        tool_names = [getattr(tool, '__name__', str(tool)) for tool in self.web_search_tools]
        if tool_names:
            await self.update_agent_instructions(f"Search tools loaded: {', '.join(tool_names)}")
        else:
            await self.update_agent_instructions("No search tools were loaded")
        
        # Mark search tools as loaded
        self.search_tools_loaded = True
        self.tool_sources.append("Search Tools")
        
        # Load job search tools next
        asyncio.create_task(self.load_job_search_tools())
        
    async def register_brave_search(self):
        """Register Brave Search tool with the agent."""
        try:
            # First try the Quality API version (highest priority)
            try:
                # Import the brave search quality API module
                try:
                    from brave_search_quality_integration import quality_web_search, get_quality_integration
                    logger.info("Using Brave Search Quality API version")
                    
                    # Test the function to ensure it's working properly
                    logger.debug(f"quality_web_search function details: {quality_web_search.__name__}, {quality_web_search.__module__}")
                    
                    # Check if API key is available
                    import os
                    api_key = os.environ.get("BRAVE_WEB_SEARCH_API_KEY")
                    if not api_key:
                        logger.warning("BRAVE_WEB_SEARCH_API_KEY environment variable not set")
                    else:
                        logger.info("BRAVE_WEB_SEARCH_API_KEY environment variable is set")
                except Exception as e:
                    logger.error(f"Error importing quality_web_search: {str(e)}")
                    raise ImportError(f"Failed to import quality_web_search: {str(e)}")
            
                @function_tool
                async def brave_search(context: RunContext, query: str, num_results: int = 5) -> str:
                    """Search the web using Brave Search Quality API specifically."""
                    try:
                        logger.debug(f"Calling quality_web_search with: query={query}, num_results={num_results}, context={context}")
                        results = await quality_web_search(context, query, num_results)
                        return results
                    except Exception as e:
                        logger.error(f"Error in brave_search function (quality): {str(e)}")
                        logger.info("Falling back to standard Brave Search API")
                        raise  # Let it fall back to the next option
                    
                # Register the tool with the agent using our duplicate-prevention method
                try:
                    # Use our new method to update agent tools
                    added_tools = await self.update_agent_tools([brave_search])
                    
                    if added_tools:
                        logger.info("Added Brave Search Quality tool to agent")
                        # Notify console
                        await self.update_agent_instructions(f"Tool added: brave_search - Search the web using Brave Search Quality API specifically")
                        
                        # Add to our web search tools list
                        self.web_search_tools.append(brave_search)
                        self.loaded_tools["brave_search"] = True
                        logger.info("Registered Brave Search tool (Quality API version)")
                    else:
                        logger.info("Brave Search Quality tool already registered")
                    
                    return  # Successfully registered Quality API version, don't try others
                except Exception as e:
                    logger.error(f"Error adding Brave Search Quality tool: {e}")
                    logger.warning("Could not add Brave Search Quality tool to agent, falling back to standard API")
                    # Continue to try standard API
            except Exception as e:
                logger.warning(f"Error setting up Brave Search Quality API: {str(e)}")
                logger.info("Falling back to standard Brave Search API")
        except ImportError as e:
            logger.warning(f"Brave Search Quality API not available: {str(e)}")
            logger.info("Falling back to standard Brave Search API")
            
        # Next try the standard API version
        try:
            # Import the brave search API module
            try:
                from brave_search_api import brave_web_search
                logger.info("Using Brave Search API version")
                
                # Test the function to ensure it's working properly
                logger.debug(f"brave_web_search function details: {brave_web_search.__name__}, {brave_web_search.__module__}")
                
                # Check if API key is available
                import os
                api_key = os.environ.get("BRAVE_WEB_SEARCH_API_KEY")
                if not api_key:
                    logger.warning("BRAVE_WEB_SEARCH_API_KEY environment variable not set")
                else:
                    logger.info("BRAVE_WEB_SEARCH_API_KEY environment variable is set")
            except Exception as e:
                logger.error(f"Error importing brave_web_search: {str(e)}")
                raise ImportError(f"Failed to import brave_web_search: {str(e)}")
            
            @function_tool
            async def brave_search(context: RunContext, query: str, num_results: int = 5) -> str:
                """Search the web using Brave Search API specifically."""
                try:
                    logger.debug(f"Calling brave_web_search with: query={query}, num_results={num_results}, context={context}")
                    results = await brave_web_search(query, num_results, context)
                    return results
                except Exception as e:
                    logger.error(f"Error in brave_search function: {str(e)}")
                    return f"Error searching with Brave: {str(e)}"
                    
            # Register the tool with the agent using our duplicate-prevention method
            try:
                # Use our new method to update agent tools
                added_tools = await self.update_agent_tools([brave_search])
                
                if added_tools:
                    logger.info("Added Brave Search tool to agent")
                    # Notify console
                    await self.update_agent_instructions(f"Tool added: brave_search - Search the web using Brave Search API specifically")
                    
                    # Add to our web search tools list
                    self.web_search_tools.append(brave_search)
                    self.loaded_tools["brave_search"] = True
                    logger.info("Registered Brave Search tool (API version)")
                else:
                    logger.info("Brave Search tool already registered")
            except Exception as e:
                logger.error(f"Error adding Brave Search tool: {e}")
                logger.warning("Could not add Brave Search tool to agent")
                
            logger.info("Registered Brave Search tool")
        except ImportError:
            logger.warning("Brave Search API not available")
            self.loaded_tools["brave_search"] = False
            
    async def register_bing_search(self):
        """Register the Bing Search tool with the agent."""
        try:
            logger.info("Using Bing Search nokey version")
            from bing_search_nokey import bing_search as bing_search_func
            
            logger.debug(f"bing_search_func function details: {bing_search_func.__name__}, {bing_search_func.__module__}")
            import inspect
            logger.debug(f"bing_search_func signature: {inspect.signature(bing_search_func)}")
            
            @function_tool
            async def bing_search(context: RunContext, query: str, num_results: int = 5) -> str:
                """Search the web using Bing specifically."""
                logger.debug(f"Calling bing_search with: query={query}, num_results={num_results}, context={context}")
                results = await bing_search_func(context, query, num_results)
                return results
            
            # Register the tool
            await self.update_agent_tools([bing_search])
            logger.info("Added Bing Search tool to agent")
            logger.info("Agent status update: Tool added: bing_search - Search the web using Bing specifically")
            await self.update_agent_instructions("Tool added: bing_search - Search the web using Bing specifically")
            logger.info("Registered Bing Search tool")
            self.web_search_tools.append(bing_search)
            self.loaded_tools["bing_search"] = True
        except Exception as e:
            logger.error(f"Error registering Bing Search: {str(e)}")
            logger.error(f"Exception type: {type(e).__name__}")
            import traceback
            logger.error(f"Exception traceback: {traceback.format_exc()}")
            self.loaded_tools["bing_search"] = False
            # Don't raise the exception, just log it
            logger.warning(f"Failed to register Bing Search: {str(e)}")
            
            logger.info("Registered Bing Search tool")
        except ImportError:
            logger.warning("Bing Search not available")
            
    async def register_duckduckgo_search(self):
        """Register DuckDuckGo Search tool with the agent."""
        try:
            # First try the official package
            try:
                try:
                    # Check if the package is installed
                    import pkg_resources
                    try:
                        pkg_resources.get_distribution('duckduckgo-search')
                        logger.info("duckduckgo-search package is installed")
                    except pkg_resources.DistributionNotFound:
                        logger.warning("duckduckgo-search package is not installed")
                    
                    # Try importing with detailed error handling
                    import sys
                    logger.debug(f"Python path: {sys.path}")
                    
                    # Check for circular imports
                    import os
                    if os.path.exists(os.path.join(os.path.dirname(__file__), 'duckduckgo_search.py')):
                        logger.warning("Found local duckduckgo_search.py file - potential circular import issue")
                    
                    from duckduckgo_search import DDGS
                    logger.info("Successfully imported DDGS from duckduckgo_search")
                    logger.debug(f"DDGS class details: {DDGS.__module__}")
                except Exception as detailed_error:
                    logger.error(f"Detailed error importing DDGS: {str(detailed_error)}")
                    if "circular import" in str(detailed_error).lower():
                        logger.error("Detected circular import issue with duckduckgo_search")
                    raise ImportError(f"Failed to import DDGS: {str(detailed_error)}")
                
                logger.info("Using official DuckDuckGo Search package")
                
                @function_tool
                async def duckduckgo_search(context: RunContext, query: str, num_results: int = 5) -> str:
                    """Search the web using DuckDuckGo specifically."""
                    try:
                        logger.debug(f"Creating DDGS instance for query: {query}")
                        # Create DDGS instance without using it as an async context manager
                        ddgs = DDGS()
                        logger.debug("DDGS instance created successfully")
                        # Use the text method directly (it's not async in the official package)
                        results = [r for r in ddgs.text(query, max_results=num_results)]
                        logger.debug(f"Got {len(results)} results from DuckDuckGo")
                        return str(results)
                    except Exception as e:
                        logger.error(f"Error in duckduckgo_search function: {str(e)}")
                        return f"Error searching with DuckDuckGo: {str(e)}"
            except ImportError as e:
                # Fall back to our custom implementation
                logger.warning(f"Official DuckDuckGo Search package not available: {str(e)}")
                logger.info("Using custom DuckDuckGo Search nokey implementation")
                
                try:
                    from duckduckgo_search_nokey import duckduckgo_search as duckduckgo_search_func
                    logger.info("Successfully imported custom duckduckgo_search_nokey implementation")
                    logger.debug(f"duckduckgo_search_func details: {duckduckgo_search_func.__name__}, {duckduckgo_search_func.__module__}")
                    
                    # Test the function to ensure it's properly defined
                    import inspect
                    logger.debug(f"duckduckgo_search_func signature: {inspect.signature(duckduckgo_search_func)}")
                except Exception as custom_error:
                    logger.error(f"Error importing custom duckduckgo_search_nokey: {str(custom_error)}")
                    # Check if the file exists
                    import os
                    if os.path.exists(os.path.join(os.path.dirname(__file__), 'duckduckgo_search_nokey.py')):
                        logger.info("duckduckgo_search_nokey.py file exists but has errors")
                    else:
                        logger.warning("duckduckgo_search_nokey.py file does not exist")
                    raise ImportError(f"Failed to import custom duckduckgo_search_nokey: {str(custom_error)}")
                
                @function_tool
                async def duckduckgo_search(context: RunContext, query: str, num_results: int = 5) -> str:
                    """Search the web using DuckDuckGo specifically."""
                    try:
                        logger.debug(f"Calling duckduckgo_search_func with: context={context}, query={query}, num_results={num_results}")
                        results = await duckduckgo_search_func(context, query, num_results)
                        return results
                    except Exception as e:
                        logger.error(f"Error in duckduckgo_search function (custom): {str(e)}")
                        return f"Error searching with DuckDuckGo: {str(e)}"
        except ImportError as e:
            logger.warning(f"DuckDuckGo Search not available: {str(e)}")
            logger.warning("Try installing with: pip install duckduckgo-search")
            return

        # Register the tool with the agent using our duplicate-prevention method
        try:
            # Use our new method to update agent tools
            added_tools = await self.update_agent_tools([duckduckgo_search])
            
            if added_tools:
                logger.info("Added DuckDuckGo Search tool to agent")
                # Notify console
                await self.update_agent_instructions(f"Tool added: duckduckgo_search - Search the web using DuckDuckGo specifically")
                
                # Add to our web search tools list
                self.web_search_tools.append(duckduckgo_search)
                self.loaded_tools["duckduckgo_search"] = True
                logger.info("Registered DuckDuckGo Search tool")
            else:
                logger.info("DuckDuckGo Search tool already registered")
        except Exception as e:
            logger.error(f"Error adding DuckDuckGo Search tool: {e}")
            logger.warning("Could not add DuckDuckGo Search tool to agent")
    
    async def register_google_search(self):
        """Register Google Search tool with the agent."""
        try:
            try:
                from google_search_nokey import google_search as google_search_func
                logger.info("Using Google Search nokey version")
                logger.debug(f"google_search_func function details: {google_search_func.__name__}, {google_search_func.__module__}")
                
                # Test the function to ensure it's properly defined
                import inspect
                logger.debug(f"google_search_func signature: {inspect.signature(google_search_func)}")
                
                # Check if the required packages are installed
                import pkg_resources
                try:
                    pkg_resources.get_distribution('googlesearch-python')
                    logger.info("googlesearch-python package is installed")
                except pkg_resources.DistributionNotFound:
                    try:
                        pkg_resources.get_distribution('google-search')
                        logger.info("google-search package is installed")
                    except pkg_resources.DistributionNotFound:
                        logger.warning("Neither googlesearch-python nor google-search packages are installed")
            except Exception as e:
                logger.error(f"Error importing google_search_nokey: {str(e)}")
                # Check if the file exists
                import os
                if os.path.exists(os.path.join(os.path.dirname(__file__), 'google_search_nokey.py')):
                    logger.info("google_search_nokey.py file exists but has errors")
                else:
                    logger.warning("google_search_nokey.py file does not exist")
                raise ImportError(f"Failed to import google_search_nokey: {str(e)}")
        except ImportError as e:
            logger.warning(f"Google Search not available: {str(e)}")
            logger.warning("Try installing with: pip install google-search-nokey")
            return

        @function_tool
        async def google_search(context: RunContext, query: str, num_results: int = 5) -> str:
            """Search the web using Google specifically."""
            try:
                logger.debug(f"Calling google_search_func with: context={context}, query={query}, num_results={num_results}")
                results = await google_search_func(context, query, num_results)
                return results
            except Exception as e:
                logger.error(f"Error in google_search function: {str(e)}")
                return f"Error searching with Google: {str(e)}"

        # Register the tool with the agent using our duplicate-prevention method
        try:
            # Use our new method to update agent tools
            added_tools = await self.update_agent_tools([google_search])
            
            if added_tools:
                logger.info("Added Google Search tool to agent")
                # Notify console
                await self.update_agent_instructions(f"Tool added: google_search - Search the web using Google specifically")
                
                # Add to our web search tools list
                self.web_search_tools.append(google_search)
                self.loaded_tools["google_search"] = True
                logger.info("Registered Google Search tool")
            else:
                logger.info("Google Search tool already registered")
        except Exception as e:
            logger.error(f"Error adding Google Search tool: {e}")
            logger.warning("Could not add Google Search tool to agent")
        logger.info("Registered Google Search tool")

    async def register_wikipedia_search(self):
        """Register Wikipedia Search tool with the agent."""
        try:
            # Import the wikipedia module
            import wikipediaapi
            
            @function_tool
            async def wikipedia_search(context: RunContext, query: str) -> str:
                """Search Wikipedia for information on a topic."""
                try:
                    wiki = wikipediaapi.Wikipedia('en')
                    page = wiki.page(query)
                    
                    if page.exists():
                        # Get a summary (first 500 characters)
                        summary = page.summary[0:500] + "..." if len(page.summary) > 500 else page.summary
                        return f"Wikipedia: {query}\n\n{summary}\n\nFull article: {page.fullurl}"
                    else:
                        return f"No Wikipedia article found for '{query}'"
                except Exception as e:
                    return f"Error searching Wikipedia: {str(e)}"
            
            # Register the tool with the agent using our duplicate-prevention method
            try:
                # Use our new method to update agent tools
                added_tools = await self.update_agent_tools([wikipedia_search])
                
                if added_tools:
                    logger.info("Added Wikipedia Search tool to agent")
                    # Notify console
                    await self.update_agent_instructions(f"Tool added: wikipedia_search - Search Wikipedia for information on a topic")
                    
                    # Add to our web search tools list
                    self.web_search_tools.append(wikipedia_search)
                    self.loaded_tools["wikipedia"] = True
                    logger.info("Registered Wikipedia Search tool")
                else:
                    logger.info("Wikipedia Search tool already registered")
            except Exception as e:
                logger.error(f"Error adding Wikipedia Search tool: {e}")
                logger.warning("Could not add Wikipedia Search tool to agent")
        except ImportError:
            logger.warning("Wikipedia API not available")
            
    async def register_web_search(self):
        """Register combined web search tool with the agent."""
        @function_tool
        async def web_search(context: RunContext, query: str, num_results: int = 5) -> str:
            """Search the web using the best available search engine."""
            # Prioritize search engines in the specified order: brave quality API → brave API → brave nokey → duckduckgo → google → bing
            # Only Brave has quality API, standard API and nokey versions, all others are nokey only
        
            # 1. Try Brave Search Quality API version first (highest priority)
            if self.has_brave_search:
                try:
                    try:
                        from brave_search_quality_integration import quality_web_search
                        logger.info("web_search using Brave Search Quality API")
                        logger.debug(f"quality_web_search function details: {quality_web_search.__name__}, {quality_web_search.__module__}")
                    except ImportError as import_error:
                        logger.error(f"Error importing quality_web_search in web_search: {str(import_error)}")
                        raise
                    
                    # Check if API key is available
                    import os
                    api_key = os.environ.get("BRAVE_WEB_SEARCH_API_KEY")
                    if not api_key:
                        logger.warning("BRAVE_WEB_SEARCH_API_KEY environment variable not set in web_search")
                
                    logger.debug(f"Calling quality_web_search with: query={query}, num_results={num_results}, context={context}")
                    results = await quality_web_search(context, query, num_results)
                    logger.debug(f"Brave Search Quality API returned results: {len(results) if isinstance(results, str) else 'non-string result'}")
                    return results
                except Exception as e:
                    logger.warning(f"Failed to use Brave Search Quality API: {str(e)}")
                    logger.debug(f"Exception type: {type(e).__name__}, details: {str(e)}")
        
            # 2. Try Brave Search API version next
            if self.has_brave_search:
                try:
                    try:
                        from brave_search_api import brave_web_search
                        logger.info("web_search using Brave Search API")
                        logger.debug(f"brave_web_search function details: {brave_web_search.__name__}, {brave_web_search.__module__}")
                    except ImportError as import_error:
                        logger.error(f"Error importing brave_web_search in web_search: {str(import_error)}")
                        raise
                    
                    # Check if API key is available
                    import os
                    api_key = os.environ.get("BRAVE_WEB_SEARCH_API_KEY")
                    if not api_key:
                        logger.warning("BRAVE_WEB_SEARCH_API_KEY environment variable not set in web_search")
                    
                    logger.debug(f"Calling brave_web_search with: query={query}, num_results={num_results}, context={context}")
                    results = await brave_web_search(query, num_results, context)
                    logger.debug(f"Brave Search API returned results: {len(results) if isinstance(results, str) else 'non-string result'}")
                    return results
                except Exception as e:
                    logger.warning(f"Failed to use Brave Search API: {str(e)}")
                    logger.debug(f"Exception type: {type(e).__name__}, details: {str(e)}")
            
            # 3. Try Brave Search nokey version
            if self.has_brave_search:
                try:
                    try:
                        from brave_search_nokey import brave_search as brave_search_nokey
                        logger.info("web_search using Brave Search nokey")
                        logger.debug(f"brave_search_nokey function details: {brave_search_nokey.__name__}, {brave_search_nokey.__module__}")
                    except ImportError as import_error:
                        logger.error(f"Error importing brave_search_nokey in web_search: {str(import_error)}")
                        raise
                    
                    logger.debug(f"Calling brave_search_nokey with: context={context}, query={query}, num_results={num_results}")
                    results = await brave_search_nokey(context, query, num_results)
                    logger.debug(f"Brave Search nokey returned results: {len(results) if isinstance(results, str) else 'non-string result'}")
                    return results
                except Exception as e:
                    logger.warning(f"Failed to use Brave Search nokey: {str(e)}")
                    logger.debug(f"Exception type: {type(e).__name__}, details: {str(e)}")
            
            # 4. Try DuckDuckGo nokey version
            if self.has_duckduckgo:
                try:
                    # First try the official package
                    try:
                        # Check for circular imports
                        import os
                        if os.path.exists(os.path.join(os.path.dirname(__file__), 'duckduckgo_search.py')):
                            logger.warning("Found local duckduckgo_search.py file in web_search - potential circular import issue")
                        
                        from duckduckgo_search import DDGS
                        logger.info("web_search using DuckDuckGo nokey (official package)")
                        logger.debug(f"DDGS class details in web_search: {DDGS.__module__}")
                    except ImportError as import_error:
                        # Try our custom implementation
                        logger.warning(f"Official DuckDuckGo package not available in web_search: {str(import_error)}")
                        logger.info("web_search using custom DuckDuckGo implementation")
                        
                        from duckduckgo_search_nokey import duckduckgo_search as ddg_search_func
                        logger.debug(f"ddg_search_func details: {ddg_search_func.__name__}, {ddg_search_func.__module__}")
                        results = await ddg_search_func(context, query, num_results)
                        logger.debug(f"Custom DuckDuckGo returned results: {len(results) if isinstance(results, str) else 'non-string result'}")
                        return results
                    
                    # If we get here, we're using the official package
                    logger.debug(f"Creating DDGS instance for query in web_search: {query}")
                    # Create DDGS instance without using it as an async context manager
                    ddgs = DDGS()
                    logger.debug("DDGS instance created successfully in web_search")
                    # Use the text method directly (it's not async in the official package)
                    results = [r for r in ddgs.text(query, max_results=num_results)]
                    logger.debug(f"Got {len(results)} results from DuckDuckGo in web_search")
                    return str(results)
                except Exception as e:
                    logger.warning(f"Failed to use DuckDuckGo nokey: {str(e)}")
                    logger.debug(f"Exception type: {type(e).__name__}, details: {str(e)}")
            
            # 5. Try Google Search nokey version
            if self.has_google_search:
                try:
                    try:
                        from google_search_nokey import google_search as google_search_nokey
                        logger.info("web_search using Google Search nokey")
                        logger.debug(f"google_search_nokey function details: {google_search_nokey.__name__}, {google_search_nokey.__module__}")
                    except ImportError as import_error:
                        logger.error(f"Error importing google_search_nokey in web_search: {str(import_error)}")
                        raise
                    
                    logger.debug(f"Calling google_search_nokey with: context={context}, query={query}, num_results={num_results}")
                    results = await google_search_nokey(context, query, num_results)
                    logger.debug(f"Google Search nokey returned results: {len(results) if isinstance(results, str) else 'non-string result'}")
                    return results
                except Exception as e:
                    logger.warning(f"Failed to use Google Search nokey: {str(e)}")
                    logger.debug(f"Exception type: {type(e).__name__}, details: {str(e)}")
                    
            # 6. Try Bing Search nokey version
            if self.has_bing_search:
                try:
                    try:
                        from bing_search_nokey import bing_search as bing_search_nokey
                        logger.info("web_search using Bing Search nokey")
                        logger.debug(f"bing_search_nokey function details: {bing_search_nokey.__name__}, {bing_search_nokey.__module__}")
                    except ImportError as import_error:
                        logger.error(f"Error importing bing_search_nokey in web_search: {str(import_error)}")
                        raise
                    
                    logger.debug(f"Calling bing_search_nokey with: context={context}, query={query}, num_results={num_results}")
                    results = await bing_search_nokey(context, query, num_results)
                    logger.debug(f"Bing Search nokey returned results: {len(results) if isinstance(results, str) else 'non-string result'}")
                    return results
                except Exception as e:
                    logger.warning(f"Failed to use Bing Search nokey: {str(e)}")
                    logger.debug(f"Exception type: {type(e).__name__}, details: {str(e)}")
            
            # Fallback to a simple message if no search engines are available
            return "No search engines are currently available. Please try again later."
        
        # Register the tool with the agent using our duplicate-prevention method
        try:
            # Use our new method to update agent tools
            added_tools = await self.update_agent_tools([web_search])
            
            if added_tools:
                logger.info("Added Web Search tool to agent")
                # Notify console
                await self.update_agent_instructions(f"Tool added: web_search - Search the web using the best available search engine")
                
                # Add to our web search tools list
                self.web_search_tools.append(web_search)
                logger.info("Registered combined web_search tool")
            else:
                logger.info("Web Search tool already registered")
        except Exception as e:
            logger.error(f"Error adding Web Search tool: {e}")
            logger.warning("Could not add Web Search tool to agent")
    
    async def load_job_search_tools(self):
        """Load job search tools if enabled."""
        logger.info("Loading job search tools")
        
        # Double-check environment variables to ensure we have the latest settings
        self.has_indeed = os.environ.get("INDEED_ENABLE", "").lower() in ("true", "1", "yes") and os.environ.get("INDEED_ENABLE", "").lower() not in ("false", "0", "no")
        self.has_locanto = os.environ.get("LOCANTO_ENABLE", "").lower() in ("true", "1", "yes") and os.environ.get("LOCANTO_ENABLE", "").lower() not in ("false", "0", "no")
        
        logger.info(f"Job search tools enabled: Indeed={self.has_indeed}, Locanto={self.has_locanto}")
        
        if self.has_indeed:
            await self.register_indeed_search()
        
        if self.has_locanto:
            await self.register_locanto_search()
        
        # Update instructions to reflect job search tools
        tool_names = [tool.__name__ for tool in self.job_search_tools]
        if tool_names:
            await self.update_agent_instructions(f"Job search tools loaded: {', '.join(tool_names)}")
        else:
            await self.update_agent_instructions("No job search tools were loaded")
        
        # Mark job search tools as loaded
        self.job_search_tools_loaded = True
        self.tool_sources.append("Job Search Tools")
        
        # Load enhanced search next if enabled
        if self.has_enhanced_search:
            asyncio.create_task(self.load_enhanced_search())
        else:
            # Otherwise, load MCP tools if enabled
            if self.has_mcp_client:
                asyncio.create_task(self.load_mcp_tools())
            else:
                # Finalize the agent configuration
                await self.finalize_agent_configuration()
        
    async def register_indeed_search(self):
        """Register Indeed job search tool with the agent."""
        try:
            # Import the indeed module
            from brave_search_indeed_optimized import indeed_job_search as indeed_search_func
            
            @function_tool
            async def indeed_job_search(context: RunContext, query: str = "customer service", location: str = "Johannesburg, Gauteng", max_results: int = 5, include_urls: bool = True) -> str:
                """Search for jobs on Indeed using Brave Search API or scraping."""
                try:
                    # Make sure we pass the parameters correctly
                    results = await indeed_search_func(query=query, location=location, max_results=max_results, include_urls=include_urls)
                    return results
                except Exception as e:
                    return f"Error searching Indeed: {str(e)}"
            
            # Register the tool with the agent using our duplicate-prevention method
            try:
                # Use our new method to update agent tools
                added_tools = await self.update_agent_tools([indeed_job_search])
                
                if added_tools:
                    logger.info("Added Indeed Job Search tool to agent")
                    # Notify console
                    await self.update_agent_instructions(f"Tool added: indeed_job_search - Search for jobs on Indeed")
                    
                    # Add to our job search tools list
                    self.job_search_tools.append(indeed_job_search)
                    logger.info("Registered Indeed job search tool")
                else:
                    logger.info("Indeed Job Search tool already registered")
            except Exception as e:
                logger.error(f"Error adding Indeed Job Search tool: {e}")
                logger.warning("Could not add Indeed Job Search tool to agent")
        except ImportError:
            logger.warning("Indeed job search not available")
            
    async def register_locanto_search(self):
        """Register Locanto search tool with the agent."""
        try:
            # Try to import the fixed locanto search function first
            try:
                from locanto_fixed import search_locanto_fixed as search_locanto
                logger.info("Added Fixed Locanto Search tool to agent")
            except ImportError:
                # Fall back to the original implementation if the fixed version is not available
                from locanto import search_locanto
                logger.info("Added Locanto Search tool to agent (original version)")
            
            # Register the tool with the agent using our duplicate-prevention method
            added_tools = await self.update_agent_tools([search_locanto])
            
            if added_tools:
                # Notify console
                await self.update_agent_instructions(f"Tool added: search_locanto - Search for listings on Locanto")
                self.loaded_tools["search_locanto"] = True
                logger.info("Registered Locanto search tool")
            else:
                logger.info("Locanto Search tool already registered")
        except Exception as e:
            logger.error(f"Error adding Locanto Search tool: {e}")
            logger.warning("Could not add Locanto Search tool to agent")
        except ImportError:
            logger.warning("Locanto search not available")
            
    async def load_enhanced_search(self):
        """Load enhanced search with RAG capabilities."""
        try:
            logger.info("Loading enhanced search with RAG")
            
            # Import the enhanced search module
            try:
                from enhanced_search import setup_enhanced_search, data_manager, get_embedding_model
                logger.info("Imported enhanced search module")
                
                # Pre-load the embedding model to ensure it's available locally
                logger.info("Pre-loading embedding model from cache...")
                model = get_embedding_model()
                if model is not None:
                    logger.info("Successfully loaded embedding model from cache")
                else:
                    logger.warning("Could not load embedding model from cache, will attempt to load when needed")
            except ImportError as e:
                logger.error(f"Error importing enhanced search module: {e}")
                return
            
            # Set up enhanced search
            enhanced_search_tools = await setup_enhanced_search(self.agent)
            
            # Import and set up Brave Search Quality RAG integration if available
            try:
                from brave_search_quality_rag_integration import get_integration, process_data_directory
                logger.info("Imported Brave Search Quality RAG integration")
                
                # Initialize the integration
                integration = get_integration()
                logger.info("Initialized Brave Search Quality RAG integration")
                
                # Process data directory in the background
                asyncio.create_task(process_data_directory())
                logger.info("Started processing data directory for RAG integration")
            except ImportError as e:
                logger.warning(f"Brave Search Quality RAG integration not available: {e}")
            
            if enhanced_search_tools:
                logger.info(f"Added {len(enhanced_search_tools)} enhanced search tools")
                
                # Start background embedding if enabled
                if self.has_background_embedding and not self.background_embedding_started:
                    logger.info("Starting background embedding process")
                    # Start background embedding in a non-blocking way
                    asyncio.create_task(data_manager.start_background_embedding())
                    self.background_embedding_started = True
                    self.loaded_tools["background_embedding"] = True
            else:
                logger.warning("No enhanced search tools were added")
                
            self.enhanced_search_loaded = True
            self.tool_sources.append("Enhanced Search")
            
        except Exception as e:
            logger.error(f"Error loading enhanced search: {e}")
            logger.warning("Enhanced search could not be loaded")

        # Update instructions to reflect enhanced search
        if self.has_enhanced_search:
            await self.update_agent_instructions("Enhanced search with RAG loaded: You can now search through local knowledge base")
        else:
            await self.update_agent_instructions("Enhanced search with RAG is not enabled")
            
        # Mark enhanced search as loaded
        self.enhanced_search_loaded = True
        self.tool_sources.append("Enhanced Search with RAG")
        logger.info("Enhanced search with RAG loaded successfully")
        
        # Load MCP tools next if enabled
        if self.has_mcp_client:
            asyncio.create_task(self.load_mcp_tools())
        else:
            # Finalize the agent configuration
            await self.finalize_agent_configuration()
                    self.loaded_tools["background_embedding"] = True
            else:
                logger.warning("No enhanced search tools were added")
                
            self.enhanced_search_loaded = True
            self.tool_sources.append("Enhanced Search")
            
        except Exception as e:
            logger.error(f"Error loading enhanced search: {e}")
            logger.warning("Enhanced search could not be loaded")

        # Update instructions to reflect enhanced search
        if self.has_enhanced_search:
            await self.update_agent_instructions("Enhanced search with RAG loaded: You can now search through local knowledge base")
        else:
            await self.update_agent_instructions("Enhanced search with RAG is not enabled")
            
        # Mark enhanced search as loaded
        self.enhanced_search_loaded = True
        self.tool_sources.append("Enhanced Search with RAG")
        logger.info("Enhanced search with RAG loaded successfully")
        
        # Load MCP tools next if enabled
        if self.has_mcp_client:
            asyncio.create_task(self.load_mcp_tools())
        else:
            # Finalize the agent configuration
            await self.finalize_agent_configuration()
        
    async def load_mcp_tools(self):
        """Load MCP tools after local tools are loaded."""
        logger.info("Loading MCP tools")
        
        try:
            # Import MCP modules
            from mcp_client import MCPServerSse, MCPToolsIntegration
            
            # Get Zapier MCP URL from environment
            zapier_mcp_url = os.environ.get("ZAPIER_MCP_URL")
            
            if zapier_mcp_url:
                try:
                    # Initialize MCP server connection
                    mcp_server = MCPServerSse(
                        params={"url": zapier_mcp_url},
                        cache_tools_list=True,
                        name="Zapier MCP Server"
                    )
                    
                    # Connect to MCP server
                    await mcp_server.connect()
                    
                    # Get available tools
                    available_tools = await mcp_server.list_tools()
                    logger.info(f"Found {len(available_tools)} tools on Zapier MCP server")
                    
                    if available_tools:
                        # Register MCP tools with the agent
                        mcp_tools = await MCPToolsIntegration.register_with_agent(
                            agent=self.agent,
                            mcp_servers=[mcp_server],
                            convert_schemas_to_strict=True,
                            auto_connect=False
                        )
                        
                        # Track tool sources
                        self.tool_sources.append("Zapier MCP")
                        
                        # Mark MCP tools as loaded
                        self.mcp_tools_loaded = True
                        
                        # Log registered tools
                        tool_names = [getattr(t, '__name__', str(t)) for t in mcp_tools]
                        logger.info(f"Registered MCP tool names: {', '.join(tool_names)}")
                    else:
                        logger.warning("No tools found on Zapier MCP server")
                except Exception as e:
                    logger.error(f"Failed to register MCP tools: {e}")
                    logger.warning("MCP tools will not be available")
            else:
                logger.warning("ZAPIER_MCP_URL not found in environment variables")
        except ImportError:
            logger.warning("MCP client modules not available")
        
        # Update agent instructions with all tools
        await self.update_agent_instructions("MCP tools loaded")
        
        # Finalize the agent configuration
        await self.finalize_agent_configuration()
        
    async def update_agent_instructions(self, status_message):
        """
        Update the agent's instructions to reflect current capabilities.
        
        Args:
            status_message: A message indicating what has been loaded
        """
        # Log the status message
        logger.info(f"Agent status update: {status_message}")
        
        # Send a message to the console to indicate tool availability
        # We can't directly send messages to the console, so we'll just log it
        # The user will see the loaded tools in the log output
        
        # Update the agent's instructions with the current capabilities
        current_date = datetime.now().strftime("%Y-%m-%d")
        tool_sources_str = ", ".join(self.tool_sources)
        
        updated_instructions = f"""
            You are Amanda, an advanced AI assistant.
            Your primary goal is to be helpful, informative, and efficient in your responses.
            
            It is now {current_date}.
            
            Available tool sources: {tool_sources_str}
            
            Status: {status_message}
        """
        
        # Update the agent's instructions
        try:
            await self.agent.update_instructions(updated_instructions)
        except Exception as e:
            logger.error(f"Error updating agent instructions: {e}")
        
        # Build the full instructions
        instructions = f"""
            You are Amanda, an advanced AI assistant with access to a comprehensive set of tools and capabilities.
            Your primary goal is to be helpful, informative, and efficient in your responses.
            
            It is now {current_date}.
        """
        
        # Add Brave Search info if available
        if self.has_brave_search:
            instructions += """
            You are using the optimized Brave Search API for web searches, which is highly efficient with caching.
            """
        
        # Add search instructions if search tools are loaded
        if self.search_tools_loaded:
            instructions += """
            IMPORTANT: When asked to search for information or look something up, ALWAYS use the web_search tool by default.
            The web_search tool automatically prioritizes Brave Search for the best results.
            """
            
            # Add provider-specific search tools info
            available_search_providers = []
            if self.has_brave_search:
                available_search_providers.append("brave_search: Uses Brave Search API specifically (preferred for most searches)")
            if self.has_bing_search:
                available_search_providers.append("bing_search: Uses Bing search specifically")
            if self.has_duckduckgo:
                available_search_providers.append("duckduckgo_search: Uses DuckDuckGo search specifically")
            if self.has_google_search:
                available_search_providers.append("google_search: Uses Google search specifically (use only when explicitly requested)")
            
            if available_search_providers:
                instructions += """
                You also have access to provider-specific search tools that can be used when explicitly requested:
                - """
                instructions += "\n                - ".join(available_search_providers)
        
        # Add tool sources info
        if self.tool_sources:
            instructions += f"""
            
            You have access to tools from the following sources: {tool_sources_str}
            """
        
        # Add information about available tools based on what's loaded
        available_tools = []
        
        if self.basic_tools_loaded:
            available_tools.append("Time and date tools (get_current_time, get_current_date)")
        
        if self.search_tools_loaded:
            available_tools.append("Web search tools (web_search, brave_search, bing_search, duckduckgo_search, google_search, wikipedia_search)")
        
        if self.has_openweather:
            available_tools.append("Weather tools (get_weather)")
        
        if len(self.job_search_tools) > 0:
            job_tools = []
            if self.has_indeed:
                job_tools.append("indeed_job_search")
            if self.has_locanto:
                job_tools.append("search_locanto")
            if job_tools:
                available_tools.append(f"Job search tools ({', '.join(job_tools)})")
        
        if self.enhanced_search_loaded:
            available_tools.append("Enhanced search with RAG for local documents")
        
        if available_tools:
            instructions += """
            
            Available tools include:
            - """
            instructions += "\n            - ".join(available_tools)
        
        if self.mcp_tools_loaded:
            instructions += """
            
            External MCP tools are now available for use.
            """
        
        # Add status message if provided
        if status_message:
            instructions += f"""
            
            SYSTEM UPDATE: {status_message}
            """
        
        await self.agent.update_instructions(instructions)
        logger.info(f"Updated agent instructions: {status_message if status_message else 'General update'}")
        
    
    def is_tool_registered(self, tool) -> bool:
        """Check if a tool is already registered to prevent duplicates.
        
        Args:
            tool: The function tool to check
            
        Returns:
            bool: True if the tool is already registered, False otherwise
        """
        tool_name = tool.__name__
        return tool_name in self.registered_tool_names
        
    def register_tool_name(self, tool) -> bool:
        """Register a tool name to track it and prevent duplicates.
        
        Args:
            tool: The function tool to register
            
        Returns:
            bool: True if the tool was newly registered, False if it was already registered
        """
        tool_name = tool.__name__
        if tool_name in self.registered_tool_names:
            return False
            
        self.registered_tool_names.add(tool_name)
        return True
        
    async def update_agent_tools(self, new_tools):
        """Update the agent's tools while preventing duplicate registrations.
        
        Args:
            new_tools: List of new tools to add to the agent
            
        Returns:
            List of tools that were actually added (not duplicates)
        """
        if not new_tools:
            return []
            
        # Get current tools
        current_tools = self.agent.tools if hasattr(self.agent, 'tools') else []
        
        # Filter out tools that are already registered
        tools_to_add = []
        for tool in new_tools:
            if self.register_tool_name(tool):
                tools_to_add.append(tool)
                
        if tools_to_add:
            # Update the agent's tools
            all_tools = list(current_tools) + tools_to_add
            await self.agent.update_tools(all_tools)
            
        return tools_to_add
        
    async def finalize_agent_configuration(self):
        """Finalize the agent configuration after all tools are loaded."""
        logger.info("Finalizing agent configuration")
        
        # Update instructions with final configuration
        await self.update_agent_instructions("All tools loaded and ready")
        
        # Log completion of startup sequence
        logger.info(f"Agent startup sequence completed with tools from: {', '.join(self.tool_sources)}")
        
        # Log status of background embedding if applicable
        if self.has_background_embedding and self.background_embedding_started:
            logger.info("Background embedding process is running")
        
        # Check which tools failed to load
        failed_tools = []
        if self.has_brave_search and not self.loaded_tools["brave_search"]:
            failed_tools.append("Brave Search")
        if self.has_bing_search and not self.loaded_tools["bing_search"]:
            failed_tools.append("Bing Search")
        if self.has_duckduckgo and not self.loaded_tools["duckduckgo_search"]:
            failed_tools.append("DuckDuckGo Search")
        if self.has_google_search and not self.loaded_tools["google_search"]:
            failed_tools.append("Google Search")
        if self.has_indeed and len([t for t in self.job_search_tools if "indeed" in str(t).lower()]) == 0:
            failed_tools.append("Indeed Job Search")
        if self.has_locanto and len([t for t in self.job_search_tools if "locanto" in str(t).lower()]) == 0:
            failed_tools.append("Locanto Search")
        
        if failed_tools:
            logger.warning(f"The following tools failed to load: {', '.join(failed_tools)}")
        
        # Log completion message
        logger.info("Agent is fully operational with all available tools loaded")

# Function to use in the agent's entrypoint
async def optimized_entrypoint(ctx: JobContext):
    """
    Optimized entrypoint function for the LiveKit Amanda agent.
    
    Args:
        ctx: The job context for the agent
    """
    # Create the agent with minimal initial instructions
    current_date = datetime.now().strftime("%Y-%m-%d")
    initial_instructions = f"""
        You are Amanda, an advanced AI assistant.
        Your primary goal is to be helpful, informative, and efficient in your responses.
        
        It is now {current_date}.
        
        I'm currently loading tools and capabilities. I'll be fully operational shortly.
        I can already respond to general questions and requests.
    """
    
    # Import necessary components for voice capabilities
    from livekit.plugins import azure, openai, silero
    
    # Create the agent with voice capabilities
    agent = Agent(
        instructions=initial_instructions,
        stt=azure.STT(
            speech_key=os.environ["AZURE_STT_API_KEY"],
            speech_region=os.environ["AZURE_STT_REGION"]
        ),
        llm=openai.LLM.with_azure(
            api_key=os.environ["AZURE_OPENAI_API_KEY"],
            azure_endpoint=os.environ["AZURE_OPENAI_ENDPOINT"],
            azure_deployment=os.environ["AZURE_OPENAI_DEPLOYMENT"],
            api_version=os.environ["AZURE_OPENAI_VERSION"],
            temperature=0.3,  # Lower temperature for more focused and consistent responses
            parallel_tool_calls=True,
        ),
        tts=azure.TTS(
            speech_key=os.environ["AZURE_TTS_API_KEY"],
            speech_region=os.environ["AZURE_TTS_REGION"]
        ),
        vad=silero.VAD.load(
            activation_threshold=0.7,  # Slightly lower threshold for better voice detection
            min_speech_duration=0.2,  # Shorter minimum speech duration (in seconds)
            min_silence_duration=0.2,  # Shorter silence duration for quicker response (in seconds)
            sample_rate=16000,  # Explicitly set sample rate
            force_cpu=True,  # Use CPU for better stability
            prefix_padding_duration=0.3  # Add small padding before speech
        ),
        allow_interruptions=True
    )
    
    # Create the optimizer
    optimizer = AgentStartupOptimizer()
    
    # Initialize the agent with optimized startup sequence
    await optimizer.initialize_agent(agent, ctx)
    
    # The agent is now responsive and will load additional tools in the background
    logger.info("Agent is now responsive and loading additional tools in the background")
    
    # Return the agent to prevent it from being garbage collected
    return agent
